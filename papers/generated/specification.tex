% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\documentclass[
]{article}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% definitions for citeproc citations
\NewDocumentCommand\citeproctext{}{}
\NewDocumentCommand\citeproc{mm}{%
  \begingroup\def\citeproctext{#2}\cite{#1}\endgroup}
\makeatletter
 % allow citations to break across lines
 \let\@cite@ofmt\@firstofone
 % avoid brackets around text for \cite:
 \def\@biblabel#1{}
 \def\@cite#1#2{{#1\if@tempswa , #2\fi}}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newenvironment{CSLReferences}[2] % #1 hanging-indent, #2 entry-spacing
 {\begin{list}{}{%
  \setlength{\itemindent}{0pt}
  \setlength{\leftmargin}{0pt}
  \setlength{\parsep}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
   \setlength{\leftmargin}{\cslhangindent}
   \setlength{\itemindent}{-1\cslhangindent}
  \fi
  % set entry spacing
  \setlength{\itemsep}{#2\baselineskip}}}
 {\end{list}}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{\hfill\break\parbox[t]{\linewidth}{\strut\ignorespaces#1\strut}}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Wamu: A Protocol for Computation of Threshold Signatures by Multiple Cryptographic Identities},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Wamu: A Protocol for Computation of Threshold Signatures by
Multiple Cryptographic Identities}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Technical Specification}
\author{David Semakula\\
hello@davidsemakula.com\\
https://davidsemakula.com}
\date{Published: 15th May, 2023\\
Last Updated: 19th November, 2025\\
Version: 1.6.1}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{3}
\tableofcontents
}
\subsection{1. Introduction}\label{introduction}

This document describes the Wamu protocol which augments a
state-of-the-art non-interactive threshold signature scheme
(e.g.~CGGMP20 {[}\citeproc{ref-cggmp20}{1}{]}) by cryptographically
associating each signing party with a cryptographic identity. This is
achieved by:

\begin{itemize}
\tightlist
\item
  Splitting the secret share for each party between the party and the
  output of a signing operation by its associated cryptographic
  identity, thus making the signing operation a requirement for
  reconstructing the party's secret share.
\item
  Adding peer-to-peer cryptographic identity authentication to the key
  generation and signing protocols (and optionally to the key refresh
  protocol) of the threshold signature scheme.
\item
  Defining protocols for identity rotation, access structure
  modification (i.e.~share addition and removal and threshold
  modification) and share recovery that build on top of the above 2
  augmentations.
\end{itemize}

Wamu is designed to operate in a decentralized, trust-minimized and
asynchronous setting with:

\begin{itemize}
\tightlist
\item
  no centralized or trust-based identity infrastructure.
\item
  signing parties being mainstream consumer devices communicating
  asynchronously.
\end{itemize}

\textbf{NOTE:} For interoperability with existing wallet solutions, the
only requirement for cryptographic identity providers is the ability to
compute cryptographic signatures for any arbitrary message in such a way
that the output signature is 1) deterministic and 2) can be verified in
a non-interactive manner.

\subsection{2. Preliminaries}\label{preliminaries}

The rest of this document describes the Wamu protocol in technical
detail. For these descriptions, we'll use the following notation:

\begin{itemize}
\tightlist
\item
  \(P\) denotes a party.
\item
  \(I\) denotes a cryptographic identity.
\item
  \(vk\) denotes the verifying key (or address) of a cryptographic
  identity.
\item
  \(sk\) denotes the secret key of a cryptographic identity.
\item
  \(\mathtt{Sig}\) denotes a signing algorithm.
\item
  \(\mathtt{Ver}\) denotes a signature verification algorithm.
\item
  \(q\) denotes the prime order of the cyclic group of the elliptic
  curve.
\item
  \(\mathcal{S}\) denotes the set of verified cryptographic identities
  for all parties.
\item
  \(t\) denotes the threshold (i.e.~the minimum number of signatories
  required to jointly compute a valid signature using the threshold
  signature scheme).
\item
  \(A\) denotes a predefined prefix chosen to ensure that signatures
  computed for identity authentication cannot be valid transaction
  signatures.
\item
  \(\Vert\) denotes concatenation using an unambiguous encoding scheme.
\end{itemize}

\textbf{NOTE:} While the augmenting protocols in this document are
described in relation to the current (circa. 2023) state-of-the-art
CGGMP20 {[}\citeproc{ref-cggmp20}{1}{]} non-interactive threshold
signature scheme for ECDSA signatures, Wamu is a generic protocol that
can be adapted to any non-interactive threshold signature scheme
(e.g.~GG20 {[}\citeproc{ref-gg20}{2}{]}, CMP20
{[}\citeproc{ref-cmp20}{3}{]} and FROST20
{[}\citeproc{ref-frost20}{4}{]}) that allows for asynchronous
communication between signing parties.

\subsection{3. Share Splitting and
Reconstruction}\label{share-splitting-and-reconstruction}

Given a secret share \(x\) for a party \(P\) with an associated
cryptographic identity \(I\), the share splitting and reconstruction
protocol describes how to split \(x\) between \(P\) and the output of a
signing operation \(\mathtt{Sig}\) by \(I\) so that the output of
\(\mathtt{Sig}\) is required to reconstruct the secret share \(x\).

This is achieved by generating a message \(k\) (we'll refer to this
message as the ``signing share'') and computing a ``sub-share''
\(\beta\) (i.e a share of the secret share \(x\)) in such a way that
\(k\) needs to be signed by \(I\) using \(\mathtt{Sig}\) to produce
another ``sub-share'' \(\alpha\), such that \(\alpha\) and \(\beta\) are
shares of \(x\) under Shamir's secret-sharing scheme
{[}\citeproc{ref-sss79}{5}{]}.

\textbf{NOTE:} Share splitting and reconstruction is a single-party
localized concern that happens after (and is not related to) the
distributed key generation (DKG) protocol of the threshold signature
scheme.

\subsubsection{3.1. Share splitting}\label{share-splitting}

Given a secret share \(x\) as input and access to the cryptographic
identity \(I\) with secret key \(sk\), the share splitting protocol
proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Sample a random message \(k\) (i.e.~the signing share).
\item
  Compute a signature \((r, s) \leftarrow \mathtt{Sig}(sk, k)\).
\item
  Compute the first sub-share of \(x\) as the point
  \(\alpha = (r, s) \pmod q\).
\item
  Generate a line \(L\) (i.e a polynomial of degree 1) such that
  \(\alpha\) is a point on the line and \(x\) is the constant term
  (i.e.~Polynomial Interpolation
  {[}\citeproc{ref-wiki:interpolation}{6}{]})
\item
  Compute another point \(\beta\) from \(L\) such that
  \(\beta \neq \alpha\), \(\beta\) becomes the second sub-share of
  \(x\).
\item
  Erase both \(\alpha\) and \(L\) from memory.
\item
  Return the signing share \(k\) and the sub-share \(\beta\).
\end{enumerate}

\subsubsection{3.2. Share reconstruction}\label{share-reconstruction}

Given a signing share \(k\) and a sub-share \(\beta\) as input (i.e.~the
outputs of the share splitting protocol in
\hyperref[share-splitting]{section 3.1}) and access to the cryptographic
identity \(I\) with secret key \(sk\), the share reconstruction protocol
proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compute a signature \((r, s) \leftarrow \mathtt{Sig}(sk, k)\).
\item
  Compute a sub-share \(\alpha\) as the point
  \(\alpha = (r, s) \pmod q\).
\item
  Generate the line \(L\) by performing Polynomial Interpolation
  {[}\citeproc{ref-wiki:interpolation}{6}{]} using \(\alpha\) and
  \(\beta\) as inputs.
\item
  Compute \(x\) as the constant term of \(L\).
\item
  Erase both \(\alpha\) and \(L\) from memory.
\item
  Return \(x\) as the secret share.
\end{enumerate}

\textbf{NOTE:} The signature parameters \(r\) and \(s\) in
\((r, s) \leftarrow \mathtt{Sig}(sk, k)\) are already computed modulo
\(q\). We use the notation \(\alpha \leftarrow (r, s) \pmod q\) for the
sub-share to make it clear (at a glance) that the sub-shares are
computed using finite field arithmetic.

\subsection{4. Threshold Signature Scheme
Augmentations}\label{augmentations}

The general approach for augmenting threshold signature protocols
(i.e.~key generation and signing - and optionally key refresh) is for
each party to sign a non-interactive replay resistant challenge during
the first round of communication to prove that it currently controls the
associated cryptographic identity. The other parties then verify the
challenge signature at the beginning of the next round or identify the
culprit and halt.

Key generation and key refresh protocols typically include a commitment
to secret and random values in their first round while signing includes
an arbitrary message, so either a commitment (e.g.~for key generation
and key refresh) or the message (e.g.~for signing) is unambiguously
concatenated with a protocol specific prefix and the current timestamp
to generate a non-interactive replay resistant challenge.

\textbf{NOTE:} While most threshold signature schemes don't define a key
refresh protocol (e.g.~GG20 {[}\citeproc{ref-gg20}{2}{]} and FROST20
{[}\citeproc{ref-frost20}{4}{]}), it is relatively straightforward to
derive such a protocol from a standard proactive secret sharing scheme
like HJKY95 {[}\citeproc{ref-hjky95}{7}{]}. However, for applications
that require support for access structure modification, it is preferable
to derive a key refresh protocol from a share redistribution scheme like
DJ97 {[}\citeproc{ref-dj97}{8}{]} or WW01 {[}\citeproc{ref-ww01}{9}{]},
as the latter are more flexible and allow for both proactive security
and access structure changes (see
\hyperref[access-structure-modification]{section 6} for details and
additional considerations).

\textbf{NOTE:} While general \((t, n)\) sharing (and specifically the
case where \(t < n\)) is not formally specified in CGGMP20
{[}\citeproc{ref-cggmp20}{1}{]}, it can be derived in a relatively
straightforward manner based on GG18 {[}\citeproc{ref-gg18}{10}{]} (and
GG20 {[}\citeproc{ref-gg20}{2}{]}) for the key generation and signing
protocols (as described in section 1.2.8 of CGGMP20
{[}\citeproc{ref-cggmp20}{1}{]}) and HJKY95
{[}\citeproc{ref-hjky95}{7}{]} (or WW01 {[}\citeproc{ref-ww01}{9}{]})
for the key refresh protocol. In particular, this entails performing
\(t\)-out-of-\(n\) Feldman's verifiable secret sharing
{[}\citeproc{ref-feldman-vss}{11}{]} of the secret shares for key
generation (as described in section 2.8 and phase 2 of section 3.1 in
GG20 {[}\citeproc{ref-gg20}{2}{]} and similarly in section 2.6 and phase
2 of section 4.1 in GG18 {[}\citeproc{ref-gg18}{10}{]}) or refresh
shares for key refresh (with some modifications as described in sections
3.3 and 3.4 of HJKY95 {[}\citeproc{ref-hjky95}{7}{]} or in section 4 of
WW01 {[}\citeproc{ref-ww01}{9}{]}), and transforming \((t, n)\) to
\((t, t+1)\) shares (using the appropriate Lagrangian coefficients) for
pre-signing and signing (as described in section 3.2 in GG20
{[}\citeproc{ref-gg20}{2}{]} and similarly in section 4.2 in GG18
{[}\citeproc{ref-gg18}{10}{]}).

\subsubsection{4.1. Key Generation}\label{key-generation}

Follow the key generation protocol described in section 3.1 and figure 5
of CGGMP20 {[}\citeproc{ref-cggmp20}{1}{]} to generate ECDSA secret
shares with the following modifications:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  At the end of Round 1, broadcast 2 additional parameters for each
  \(P_i\) associated with the cryptographic identity \(I_i\) with
  verifying key \(vk_i\) and secret key \(sk_i\) as follows:

  \begin{itemize}
  \tightlist
  \item
    The cryptographic identity verifying key \(vk_i\).
  \item
    The current UTC timestamp \(\Delta\).
  \item
    The signature
    \(\sigma _i \leftarrow \mathtt{Sig}(sk_i, A \Vert \Delta \Vert V_i)\).
  \end{itemize}
\item
  At the beginning of Round 2, for each \(P_i\), verify \(\sigma _j\)
  from all \(P_j\) where \(j \neq i\):

  \begin{itemize}
  \tightlist
  \item
    Verify that \(vk_i \in \mathcal{S}\) or report the culprit and halt.
  \item
    Verify \(\sigma _j\) by checking that the output of
    \(\mathtt{Ver}(vk_j, A \Vert \Delta \Vert V_j, \sigma _j)\) is valid
    or report the culprit and halt.
  \end{itemize}
\item
  After the Output phase, follow the share splitting protocol in
  \hyperref[share-splitting]{section 3.1} to split secret share \(x_i\)
  into a signing share \(k_i\) and a sub-share \(\beta _i\) for each
  party \(P_i\).
\item
  Modify Stored State for each \(P_i\) as follows:

  \begin{itemize}
  \tightlist
  \item
    Don't store \(x_i\).
  \item
    Add \(vk_i\), \(k_i\) and \(\beta _i\).
  \end{itemize}
\end{enumerate}

\subsubsection{4.2. Signing}\label{signing}

Follow the signing protocol described in sections 4.2 and 4.3 and figure
8 of CGGMP20 {[}\citeproc{ref-cggmp20}{1}{]} to generate an ECDSA
signature with the following modifications:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Before Round 1, for each party \(P_i\), follow the share
  reconstruction protocol in \hyperref[share-reconstruction]{section
  3.2} to reconstruct secret share \(x_i\).
\item
  At the end of Round 1, for each \(P_i\) associated with the
  cryptographic identity \(I_i\) with verifying key \(vk_i\) and secret
  key \(sk_i\), send 2 additional parameters to all \(P_j\) where
  \(j \neq i\) as follows:

  \begin{itemize}
  \tightlist
  \item
    The cryptographic identity verifying key \(vk_i\).
  \item
    The current UTC timestamp \(\Delta\).
  \item
    The signature
    \(\sigma _i \leftarrow \mathtt{Sig}(sk_i, A \Vert \Delta \Vert m)\).
  \end{itemize}
\item
  At the beginning of the Output phase, verify \(\sigma _j\) from all
  \(P_j\) where \(j \neq i\) as follows:

  \begin{itemize}
  \tightlist
  \item
    Verify that \(vk_i \in \mathcal{S}\) or report the culprit and halt.
  \item
    Verify that \(t\) is within the current epoch for identity
    authenticated requests or report the culprit and halt.
  \item
    Verify \(\sigma _i\) by checking that the output of
    \(\mathtt{Ver}(vk_i, A \Vert \Delta \Vert m, \sigma _i)\) is valid
    or report the culprit and halt.
  \end{itemize}
\end{enumerate}

\subsubsection{4.3. Key Refresh}\label{key-refresh}

Follow the key refresh protocol described in section 3.2 and figure 6 of
CGGMP20 {[}\citeproc{ref-cggmp20}{1}{]} to generate new ECDSA secret
shares with the following modifications:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  At the end of Round 1, broadcast 2 additional parameters for each
  \(P_i\) associated with the cryptographic identity \(I_i\) with
  verifying key \(vk_i\) and secret key \(sk_i\) as follows:

  \begin{itemize}
  \tightlist
  \item
    The cryptographic identity verifying key \(vk_i\).
  \item
    The current UTC timestamp \(\Delta\).
  \item
    The signature
    \(\sigma _i \leftarrow \mathtt{Sig}(sk_i, A \Vert \Delta \Vert V_i)\).
  \end{itemize}
\item
  At the beginning of Round 2, for each \(P_i\), verify \(\sigma _j\)
  from all \(P_j\) where \(j \neq i\) as follows:

  \begin{itemize}
  \tightlist
  \item
    Verify that \(vk_i \in \mathcal{S}\) or report the culprit and halt.
  \item
    Verify \(\sigma _i\) by checking that the output of
    \(\mathtt{Ver}(vk_j, A \Vert \Delta \Vert V_j, \sigma _j)\) is valid
    or report the culprit and halt.
  \end{itemize}
\item
  After the Output phase, follow the share splitting protocol in
  \hyperref[share-splitting]{section 3.1} to split the new secret share
  \(x_i^\ast\) into a new signing share \(k_i^\ast\) and a new sub-share
  \(\beta _i^\ast\) for each party \(P_i\).
\item
  Modify Stored State for each \(P_i\) as follows:

  \begin{itemize}
  \tightlist
  \item
    Don't store \(x_i^\ast\).
  \item
    Replace \(k_i\) with \(k_i^\ast\) and \(\beta _i\) with
    \(\beta _i^\ast\).
  \end{itemize}
\end{enumerate}

\subsection{5. Identity Authentication and Quorum
Approval}\label{identity-auth-and-quorum-approval}

\subsubsection{5.1. Identity Authenticated
Request}\label{identity-authed-request}

Cryptographic identity authenticated requests allow parties to perform
or request actions based on their associated cryptographic identity.

\paragraph{5.1.1. Identity Authenticated Request
Initiation}\label{identity-authed-request-initiation}

To initiate an identity authenticated request with a command \(C\) from
a party \(P_i\) associated with cryptographic identity \(I_i\) with
verifying key \(vk_i\) and secret key \(sk_i\):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Read the current UTC timestamp \(\Delta\).
\item
  Compute the signature
  \(\sigma \leftarrow \mathtt{Sig}(sk_i, A \Vert \Delta \Vert C)\).
\item
  Broadcast \(C\), \(vk_i\), \(\Delta\) and \(\sigma\).
\end{enumerate}

\paragraph{5.1.2. Identity Authenticated Request
Verification}\label{identity-authed-request-verification}

To verify an identity authenticated request with a command \(C\) from a
party \(P_i\) given its associated cryptographic identity verifying key
\(vk_i\), a timestamp \(\Delta\), a signature \(\sigma\) and a set of
verified cryptographic identities for all other parties \(\mathcal{S}\)
as input:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Verify that \(vk_i \in \mathcal{S}\) or report the culprit and halt.
\item
  Verify that \(t\) is within the current epoch for identity
  authenticated requests or report the culprit and halt.
\item
  Verify \(\sigma\) by checking that the output of
  \(\mathtt{Ver}(vk_i, A \Vert \Delta \Vert C, \sigma)\) is valid or
  report the culprit and halt.
\end{enumerate}

\subsubsection{5.2. Identity Challenge}\label{identity-challenge}

Identity challenges are used to verify that a party controls a
cryptographic identity.

\paragraph{5.2.1. Identity Challenge
Initiation}\label{identity-challenge-initiation}

To issue an identity challenge to a party \(P_i\) from all verifying
parties \(P_j\) where \(j \neq i\) for a verified request with command
\(C\) initiated at timestamp \(\Delta\): 1. Sample a random \(v_j\). 2.
Broadcast \(v_j\), \(C\) and \(\Delta\) to all parties, such that all
parties can compute \(v = \Vert _{j \neq i} \: v_j\).

\paragraph{5.2.2. Identity Challenge
Response}\label{identity-challenge-response}

For a party \(P_i\) with associated cryptographic identity secret key
\(sk_i\), to respond to an identity challenge for a command \(C\)
initiated at timestamp \(\Delta\), given \(v_j\) from all parties
\(P_j\) where \(j \neq i\):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compute \(v = \Vert _{j \neq i} \: v_j\).
\item
  Compute the signature
  \(\sigma \leftarrow \mathtt{Sig}(sk_i, A \Vert \Delta \Vert C \Vert v)\).
\item
  Broadcast \(C\), \(vk_i\), \(\Delta\) and \(\sigma\) to all verifying
  parties \(P_j\).
\end{enumerate}

\paragraph{5.2.3. Identity Challenge Response
Verification}\label{identity-challenge-verification}

To verify an identity challenge response from a party \(P_i\) for a
command \(C\) initiated at timestamp \(\Delta\), given its associated
cryptographic identity verifying key \(vk_i\), a signature \(\sigma\)
and \(v_j\) from all verifying parties \(P_j\) where \(j \neq i\) as
input:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compute \(v = \Vert _{j \neq i} \: v_j\).
\item
  Verify \(\sigma\) by checking that the output of
  \(\mathtt{Ver}(vk_i, A \Vert \Delta \Vert C \Vert v, \sigma)\) is
  valid or report the culprit and halt.
\end{enumerate}

\subsubsection{5.3. Identity Rotation}\label{identity-rotation}

Identity rotation allows any party to change the cryptographic identity
associated with its secret share.

Identity rotation for a party \(P_i\) from a cryptographic identity
\(I_i\) with verifying key \(vk_i\) and secret key \(sk_i\) to a
cryptographic identity \(I_i^ \ast\) with verifying key \(vk_i^ \ast\)
and secret key \(sk_i^ \ast\) proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  For \(P_i\), initiate an ``identity-rotation'' request by following
  the protocol in \hyperref[identity-authed-request-initiation]{section
  5.1.1}.
\item
  For all \(P_j\) where \(j \neq i\):

  \begin{itemize}
  \tightlist
  \item
    Verify the ``identity-rotation'' request by following the protocol
    in \hyperref[identity-authed-request-verification]{section 5.1.2}.
  \item
    Initiate an identity challenge for \(P_i\) by following the protocol
    in \hyperref[identity-challenge-initiation]{section 5.2.1}.
  \end{itemize}
\item
  For \(P_i\), respond to the identity challenge by following the
  protocol in \hyperref[identity-challenge-response]{section 5.2.2} with
  the following augmentations:

  \begin{itemize}
  \tightlist
  \item
    Compute an additional signature
    \(\sigma _i^ \ast \leftarrow \mathtt{Sig}(sk_i^ \ast, A \Vert \Delta \Vert C \Vert v)\).
  \item
    Add \(vk_i^ \ast\) and \(\sigma _i^ \ast\) to the broadcast
    parameters.
  \end{itemize}
\item
  For all \(P_j\) where \(j \neq i\):

  \begin{itemize}
  \tightlist
  \item
    Verify the identity challenge response from \(P_i\) by following the
    protocol in \hyperref[identity-challenge-verification]{section
    5.2.3}.
  \item
    Verify that \(P_i\) controls the new cryptographic identity
    verifying key \(vk_i^ \ast\) as follows:

    \begin{itemize}
    \tightlist
    \item
      Compute \(v = \Vert _{j \neq i} \: v_j\):
    \item
      Verify \(\sigma ^ \ast\) by checking that the output of
      \(\mathtt{Ver}(vk_i^ \ast, A \Vert \Delta \Vert C \Vert v, \sigma ^ \ast)\)
      is valid or report the culprit and halt.
    \end{itemize}
  \item
    Modify Stored State as follows:

    \begin{itemize}
    \tightlist
    \item
      Create \(\mathcal{S} ^ \ast\) by replacing \(vk_i\) with
      \(vk_i^ \ast\) in \(\mathcal{S}\).
    \item
      Replace \(\mathcal{S}\) with \(\mathcal{S} ^ \ast\).
    \end{itemize}
  \item
    Broadcast confirmation of successful rotation of the verifying key
    for \(P_i\).
  \end{itemize}
\item
  For \(P_i\), upon receiving confirmation of successful rotation from a
  quorum of \(P_j\):

  \begin{itemize}
  \tightlist
  \item
    Compute the new signing share \(k_i^ \ast\) and sub-share
    \(\beta _i^ \ast\) based on the new cryptographic identity
    \(I_i^ \ast\) as follows:

    \begin{itemize}
    \tightlist
    \item
      Compute the secret share \(x_i\) by following the share
      reconstruction protocol in \hyperref[share-reconstruction]{section
      3.2}.
    \item
      Follow the share splitting protocol in
      \hyperref[share-splitting]{section 3.1} to split \(x_i\) into a
      new signing share \(k_i^ \ast\) and a new sub-share
      \(\beta _i^ \ast\) based on the new cryptographic identity
      \(I_i^ \ast\).
    \end{itemize}
  \item
    Modify Stored State as follows:

    \begin{itemize}
    \tightlist
    \item
      Replace \(vk_i\) with \(vk_i^ \ast\) in \(\mathcal{S}\).
    \item
      Replace \(k_i\) with \(k_i^ \ast\).
    \item
      Replace \(\beta _i\) with \(\beta _i^ \ast\).
    \end{itemize}
  \end{itemize}
\end{enumerate}

\subsubsection{5.4. Quorum Approved
Request}\label{quorum-approved-request}

Quorum approved requests allow any verified party to initiate actions
that require explicit approval from a quorum of verified parties before
execution (e.g.~share addition and removal, and threshold modification).

A quorum approved request with a command \(C\) from a party \(P_i\)
associated with cryptographic identity \(I_i\) with verifying key
\(vk_i\) and secret key \(sk_i\) proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  For \(P_i\), initiate an identity authenticated request by following
  the protocol in \hyperref[identity-authed-request-initiation]{section
  5.1.1}.
\item
  For all \(P_j\) where \(j \neq i\) that approve the requested action:

  \begin{itemize}
  \tightlist
  \item
    Verify the identity authenticated request by following the protocol
    in \hyperref[identity-authed-request-verification]{section 5.1.2}.
  \item
    Initiate an identity challenge for \(P_i\) by following the protocol
    in \hyperref[identity-challenge-initiation]{section 5.2.1} with the
    following augmentations:

    \begin{itemize}
    \tightlist
    \item
      Compute a signature
      \(\sigma _j \leftarrow \mathtt{Sig}(sk_j, A \Vert \Delta \Vert C \Vert v_j)\).
    \item
      Add \(vk_j\) and \(\sigma _j\) to the broadcast parameters.
    \end{itemize}
  \end{itemize}
\item
  For \(P_i\), upon receiving an augmented identity challenge from a
  quorum \(\mathcal{S} _c\) such that
  \(\mathcal{S} _c \subseteq \mathcal{S} \land |\mathcal{S} _c| \geq t - 1\),
  respond to the identity challenge by following the protocol in
  \hyperref[identity-challenge-response]{section 5.2.2} with the
  following modifications:

  \begin{itemize}
  \tightlist
  \item
    At the beginning of the identity challenge response protocol, verify
    that approvals have been received from a valid quorum of signatories
    by checking that \(\exists \, \mathcal{S} _c \subseteq \mathcal{S}\)
    such that \(|\mathcal{S} _c| \geq t - 1\) and
    \(\forall \, vk_j \in \mathcal{S} _c\) where \(j \neq i\), the
    output of
    \(\mathtt{Ver}(vk_j, A \Vert t \Vert C \Vert v_j, \sigma _j)\) is
    valid or report the culprit and halt.
  \item
    Compute \(v\) as \(v = \Vert _{j \neq i}  \: v_j\) where
    \(v_j \in \mathcal{S} _c\).
  \item
    Add \(\mathcal{S} _c\) to the broadcast parameters.
  \end{itemize}
\item
  For all \(P_j\) where \(j \neq i\):

  \begin{itemize}
  \tightlist
  \item
    Verify the augmented identity challenge response from \(P_i\) by
    following the protocol in
    \hyperref[identity-challenge-verification]{section 5.2.3} with the
    following modifications:

    \begin{itemize}
    \tightlist
    \item
      Compute \(v\) as \(v = \Vert _{j \neq i}  \: v_j\) where
      \(v_j \in \mathcal{S} _c\).
    \end{itemize}
  \item
    Verify that a valid quorum of signatories has approved the request
    as follows:

    \begin{itemize}
    \tightlist
    \item
      Verify that \(|\mathcal{S} _c| \geq t - 1\) or report the culprit
      and halt.
    \item
      Verify that
      \(\mathcal{S} _c \subseteq \mathcal{S} \land vk_i \notin \mathcal{S} _c\)
      or report the culprit and halt.
    \item
      Verify that \(\forall \, vk_j \in \mathcal{S} _c\) where
      \(j \neq i\), the output of
      \(\mathtt{Ver}(vk_j, A \Vert \Delta \Vert C \Vert v_j, \sigma _j)\)
      is valid or report the culprit and halt.
    \end{itemize}
  \end{itemize}
\end{enumerate}

\subsection{6. Access Structure
Modification}\label{access-structure-modification}

Access structure modification allows a quorum of verified parties to
perform any of the following actions:

\begin{itemize}
\tightlist
\item
  share addition - issue a secret share to a new party and its
  associated cryptographic identity
\item
  share removal - revoke the secret share of any party.
\item
  threshold modification - change the threshold (i.e.~change the size of
  the quorum).
\end{itemize}

As noted in \hyperref[augmentations]{section 4}, most threshold
signature schemes don't define a key refresh protocol, and this is also
the case for access structure modification protocols. However, it is
similarly relatively straightforward to derive a suitable access
structure modification protocol from a standard share redistribution
scheme like DJ97 {[}\citeproc{ref-dj97}{8}{]} or WW01
{[}\citeproc{ref-ww01}{9}{]}.

In fact, for applications that require support for access structure
modification, it is preferable to replace a key refresh protocol based
on (or similar to) a proactive secret sharing scheme like HJKY95
{[}\citeproc{ref-hjky95}{7}{]} (as is the case for CGGMP20
{[}\citeproc{ref-cggmp20}{1}{]} key refresh) with a protocol based on
(or similar to) a share redistribution scheme like DJ97
{[}\citeproc{ref-dj97}{8}{]} or WW01 {[}\citeproc{ref-ww01}{9}{]} as the
latter are more flexible and allow for both proactive security and
access structure changes.

\textbf{NOTE:} For threshold signature schemes with identifiable aborts
(e.g.~CGGMP20 {[}\citeproc{ref-cggmp20}{1}{]}, GG20
{[}\citeproc{ref-gg20}{2}{]} and FROST20
{[}\citeproc{ref-frost20}{4}{]}), key refresh protocols should be
derived from verifiable share redistribution schemes like WW01
{[}\citeproc{ref-ww01}{9}{]} to preserve the same security model.

Therefore, access structure modification can be achieved by following
the augmented key refresh protocol described in
\hyperref[key-refresh]{section 4.3} of this document, with some
modifications based on a verifiable share redistribution scheme like
WW01 {[}\citeproc{ref-ww01}{9}{]} (or similar) as described above. In
particular, this entails each party (from a suitable subset of parties)
performing a \(t ^\prime\)-out-of-\(n ^\prime\) (where \(t ^\prime\) and
\(n ^\prime\) denote the new threshold and new number of parties
respectively) Feldman's verifiable secret sharing
{[}\citeproc{ref-feldman-vss}{11}{]} (with some modifications as
described in section 4 of WW01 {[}\citeproc{ref-ww01}{9}{]}) of its
current secret share (i.e.~the output from either key generation or the
most recent key refresh) with other parties (in the suitable subset).

\subsubsection{6.1. Share Addition}\label{share-addition}

Share addition for a new party \(P_i\) with associated cryptographic
identity \(I_i\) proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Initiate a quorum approved ``share-addition'' request by following the
  protocol in \hyperref[quorum-approved-request]{section 5.4}.
\item
  Follow the augmented key refresh protocol described in
  \hyperref[key-refresh]{section 4.3}, with verifiable share
  redistribution modifications as described above and with \(P_i\)
  included as a participant, if the quorum approved request above
  succeeds.
\end{enumerate}

\subsubsection{6.2. Share Removal}\label{share-removal}

Share removal for a party \(P_i\) with associated cryptographic identity
\(I_i\) proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Initiate a quorum approved ``share-removal'' request by following the
  protocol in \hyperref[quorum-approved-request]{section 5.4}.
\item
  Follow the augmented key refresh protocol described in
  \hyperref[key-refresh]{section 4.3}, with verifiable share
  redistribution modifications as described above and without \(P_i\),
  if the quorum approved request above succeeds.
\end{enumerate}

\subsubsection{6.3. Threshold
Modification}\label{threshold-modification}

Threshold modification proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Initiate a quorum approved ``threshold-modification'' request by
  following the protocol in \hyperref[quorum-approved-request]{section
  5.4}.
\item
  Follow the augmented key refresh protocol described in
  \hyperref[key-refresh]{section 4.3}, with verifiable share
  redistribution modifications as described above, if the quorum
  approved request succeeds.
\end{enumerate}

\subsection{7. Share Recovery}\label{share-recovery}

Share recovery is only possible if the user's cryptographic identity
either survived or can be recovered after the disastrous event. In
either case, there are two options for share recovery depending on:

\begin{itemize}
\tightlist
\item
  A quorum of honest parties surviving the disastrous event.
\item
  A backup (preferably encrypted) of a signing share \(k\) and sub-share
  \(\beta\) pair on user-controlled secondary or device-independent
  storage.
\end{itemize}

\subsubsection{7.1. Share recovery with a surviving quorum of honest
parties}\label{share-recovery-quorum}

If a quorum of honest parties survives the disastrous event, share
recovery can be accomplished based on peer-to-peer cryptographic
identity authentication.

Share recovery for a party \(P_i\) with associated cryptographic
identity \(I_i\) with verifying key \(vk_i\) and secret key \(sk_i\)
proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  For \(P_i\), Initiate a ``share-recovery'' request by following the
  protocol in \hyperref[identity-authed-request-initiation]{section
  5.1.1}.
\item
  For all \(P_j\) where \(j \neq i\):

  \begin{itemize}
  \tightlist
  \item
    Verify the ``share-recovery'' request by following the protocol in
    \hyperref[identity-authed-request-verification]{section 5.1.2}.
  \item
    Initiate an identity challenge for \(P_i\) by following the protocol
    in \hyperref[identity-challenge-initiation]{section 5.2.1}.
  \end{itemize}
\item
  For \(P_i\), respond to the identity challenge by following the
  protocol in \hyperref[identity-challenge-response]{section 5.2.2}.
\item
  For all \(P_j\) where \(j \neq i\), verify the identity challenge
  response from \(P_i\) by following the protocol in
  \hyperref[identity-challenge-verification]{section 5.2.3}.
\item
  Follow the key refresh protocol described in
  \hyperref[key-refresh]{section 4.3} if all verifications above pass.
\end{enumerate}

\subsubsection{7.2. Share recovery with a
backup}\label{share-recovery-backup}

\paragraph{7.2.1. Overview of share recovery with a
backup}\label{share-recovery-backup-overview}

From the share splitting and reconstruction protocol in
\hyperref[share-splitting-and-reconstruction]{section 3}, we note that
for any party \(P\), the combination of a signing share \(k\) and a
sub-share \(\beta\) alone is insufficient to reconstruct the secret
share \(x\). This is because a signature of \(k\) from the cryptographic
identity \(I\) is required to compute the sub-share \(\alpha\), so that
\(\alpha\) and \(\beta\) can then be used to reconstruct \(L\) and
compute the secret share \(x\) as the constant term of \(L\).

Therefore, a signing share \(k\) and sub-share \(\beta\) pair can be
safely backed up to user-controlled secondary (e.g.~a secondary device
or a flash drive) or device-independent storage (e.g.~Apple iCloud
\footnote{Apple iCloud. \url{https://www.icloud.com}.}, Google Drive
\footnote{Google Drive. \url{https://drive.google.com}.}, Microsoft
OneDrive \footnote{Microsoft OneDrive.
  \url{https://www.microsoft.com/en-us/microsoft-365/onedrive/online-cloud-storage}.},
Dropbox \footnote{Dropbox. \url{https://www.dropbox.com}.} e.t.c)
without exposing the secret share \(x\).

\paragraph{7.2.2. Generating an encrypted backup for share
recovery}\label{share-recovery-backup-encrypt}

For increased security, a signature of a standardized phrase can be used
as entropy for generating an encryption secret which can then be used to
encrypt the signing share \(k\) and the sub-share \(\beta\) using a
symmetric encryption algorithm before saving them to back up storage.

Given a standardized phrase \(u\), a key derivation function
\(\mathtt{H}\), a symmetric encryption algorithm \(\mathtt{E}\), this
proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compute the signature \(\sigma \leftarrow \mathtt{Sig}(sk, u)\).
\item
  Generate the encryption secret \(\varepsilon = \mathtt{H}(\sigma)\).
\item
  Compute the ciphertext for the signing share \(k\) as
  \(k_c = \mathtt{E} _{enc}(k, \varepsilon)\).
\item
  Compute the ciphertext for the sub-share \(\beta\) as
  \(\beta _c = \mathtt{E} _{enc}(\beta, \varepsilon)\).
\item
  Erase both \(\sigma\) and \(\varepsilon\) from memory.
\item
  Save \(k_c\) and \(\beta _c\) to backup storage.
\end{enumerate}

\paragraph{7.2.3. Decrypting an encrypted
backup}\label{share-recovery-backup-decrypt}

Share recovery would then start by signing this standardized phrase,
using the signature to recreate the encryption secret and then
decrypting the encrypted backup to retrieve the signing share \(k\) and
the sub-share \(\beta\).

Given a standardized phrase \(u\), a key derivation function
\(\mathtt{H}\), a symmetric encryption algorithm \(\mathtt{E}\), the
ciphertext for the signing share \(k_c\) and the ciphertext for the
sub-share \(\beta _c\), this proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compute the signature \(\sigma \leftarrow \mathtt{Sig}(sk, u)\).
\item
  Generate the encryption secret \(\varepsilon = \mathtt{H}(\sigma)\).
\item
  Compute the signing share \(k = \mathtt{E} _{dec}(k_c, \varepsilon)\).
\item
  Compute the sub-share
  \(\beta = \mathtt{E} _{dec}(\beta _c, \varepsilon)\).
\item
  Erase both \(\sigma\) and \(\varepsilon\) from memory.
\item
  Return the signing share \(k\) and the sub-share \(\beta\).
\end{enumerate}

\paragraph{7.2.4. Further security and usability considerations for
share recovery with a backup}\label{share-recovery-backup-enhancements}

For further improved security and usability, the signing share \(k\) can
be prefixed with a custom message that alerts the user to the purpose of
the signature. This can help reduce the effectiveness of an adversary
that gains access to the backup and tries to trick the user into signing
\(m\).

Additionally, it's possible to rerun the share splitting protocol to
generate a new pair of a signing share \(k^ \ast\) and a sub-share
\(\beta ^ \ast\) such that \(k^ \ast \neq k\),
\(\beta ^ \ast \neq \beta\) and \(L^ \ast \neq L\) to be specifically
used for backup and recovery. This gives us the option to have separate
signing shares for backup and recovery with customized prefixes that
make it clear to the user that they're signing a backup signing share.

Lastly, the ``backup'' signing share \(k^ \ast\) can be generated based
on user input (e.g.~a passphrase or security questions) removing the
need for it to be backed up together with a sub-share \(\beta ^ \ast\)
but instead relying on the user to provide this input during recovery as
a security-usability tradeoff.

\subsection{Acknowledgements}\label{acknowledgements}

This work is funded by a grant from the Ethereum Foundation \footnote{Ethereum
  Foundation: Ecosystem Support Program.
  \url{https://esp.ethereum.foundation}.}.

\subsection{References}\label{references}

\protect\phantomsection\label{refs}
\begin{CSLReferences}{0}{0}
\bibitem[\citeproctext]{ref-cggmp20}
\CSLLeftMargin{{[}1{]} }%
\CSLRightInline{Canetti, R., Gennaro, R., Goldfeder, S., Makriyannis, N.
and Peled, U. 2020. UC non-interactive, proactive, threshold ECDSA with
identifiable aborts. \emph{Proceedings of the 2020 ACM SIGSAC conference
on computer and communications security} (New York, NY, USA, 2020),
1769--1787. \url{https://eprint.iacr.org/2021/060}.}

\bibitem[\citeproctext]{ref-gg20}
\CSLLeftMargin{{[}2{]} }%
\CSLRightInline{Gennaro, R. and Goldfeder, S. 2020. One round threshold
ECDSA with identifiable abort. Cryptology ePrint Archive, Paper
2020/540. \url{https://eprint.iacr.org/2020/540}.}

\bibitem[\citeproctext]{ref-cmp20}
\CSLLeftMargin{{[}3{]} }%
\CSLRightInline{Canetti, R., Makriyannis, N. and Peled, U. 2020. UC
non-interactive, proactive, threshold ECDSA. Cryptology ePrint Archive,
Paper 2020/492. \url{https://eprint.iacr.org/2020/492}.}

\bibitem[\citeproctext]{ref-frost20}
\CSLLeftMargin{{[}4{]} }%
\CSLRightInline{Komlo, C. and Goldberg, I. 2020. FROST: Flexible
round-optimized schnorr threshold signatures. Cryptology ePrint Archive,
Paper 2020/852. \url{https://eprint.iacr.org/2020/852}.}

\bibitem[\citeproctext]{ref-sss79}
\CSLLeftMargin{{[}5{]} }%
\CSLRightInline{Shamir, A. 1979. How to share a secret. \emph{Commun.
ACM}. 22, 11 (Nov. 1979), 612--613.
DOI:https://doi.org/\href{https://doi.org/10.1145/359168.359176}{10.1145/359168.359176}.}

\bibitem[\citeproctext]{ref-wiki:interpolation}
\CSLLeftMargin{{[}6{]} }%
\CSLRightInline{Wikipedia. Polynomial interpolation:
\href{https://en.wikipedia.org/wiki/Polynomial_interpolation}{\emph{https://en.wikipedia.org/wiki/Polynomial\_interpolation}}.
Accessed: 2023-05-12.}

\bibitem[\citeproctext]{ref-hjky95}
\CSLLeftMargin{{[}7{]} }%
\CSLRightInline{Herzberg, A., Jarecki, S., Krawczyk, H. and Yung, M.
1995. Proactive secret sharing or: How to cope with perpetual leakage.
\emph{Advances in cryptology --- CRYPT0' 95} (Berlin, Heidelberg, 1995),
339--352. \url{https://doi.org/10.1007/3-540-44750-4_27}.}

\bibitem[\citeproctext]{ref-dj97}
\CSLLeftMargin{{[}8{]} }%
\CSLRightInline{{Desmedt, Y. and jodi, S.J.} 1997. \emph{Redistributing
secret shares to new access structures and its applications}. Technical
Report \#ISSE-TR-97-01. George Mason University, Fairfax, VA 22030,
Department of Computer Science.
\url{https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=af623000d63f4c0251936b35c057a4d46581b4de}.}

\bibitem[\citeproctext]{ref-ww01}
\CSLLeftMargin{{[}9{]} }%
\CSLRightInline{Wong, T.M. and Wing, J.M. 2001. \emph{Verifiable secret
redistribution}. Technical Report \#ADA458508. Carnegie Mellon
University, Pittsburgh, PA 15213, School of Computer Science.
\url{https://apps.dtic.mil/sti/tr/pdf/ADA458508.pdf}.}

\bibitem[\citeproctext]{ref-gg18}
\CSLLeftMargin{{[}10{]} }%
\CSLRightInline{Gennaro, R. and Goldfeder, S. 2018. Fast multiparty
threshold ECDSA with fast trustless setup. \emph{Proceedings of the 2018
ACM SIGSAC conference on computer and communications security} (New
York, NY, USA, 2018), 1179--1194.
\url{https://eprint.iacr.org/2019/114.pdf}.}

\bibitem[\citeproctext]{ref-feldman-vss}
\CSLLeftMargin{{[}11{]} }%
\CSLRightInline{Feldman, P. 1987. A practical scheme for non-interactive
verifiable secret sharing. \emph{Proceedings of the 28th annual
symposium on foundations of computer science} (USA, 1987), 427--438.
\url{https://doi.org/10.1109/SFCS.1987.4}.}

\end{CSLReferences}

\end{document}
